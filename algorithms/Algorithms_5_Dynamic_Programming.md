# Dynamic Programming

Dynamic Programming을 사용하기 위해서는 필요한 조건이 두가지가 있음. 

![5_1](./resources/5_1.png)

- #### 최적 부분 구조(Optimal Substructure)

  최적 부분구조가 있다는 것은 "**부분 문제들의 최적의 답을 이용해서 기존 문제의 최적의 답을 구할 수 있다는 것**". 

  ![5_1](./resources/5_2.png)

  피보나치수의 예시를 보면, *fib(5)*는 *fib(4)*와 *fib(3)*의 부분문제의 답을 구해서 그것을 이용해서 전체의 최적의 답을 찾을 수 있음. 그렇기 때문에 피보나치문제는 **최적부분구조**를 가지고 있는 것. 

  ![5_1](./resources/5_3.png)

  서울에서 부산으로 가는 다양한 경로가 있는데, 그 중에서 최단경로로 가는 방법을 찾고 싶음. 근데 부산으로 가기 위해서는 무조건 **H, I, J**중에 하나를 거쳐 가야 함.  

  결국 서울에서 부산으로 가는 최단경로문제는 **서울에서 H로 가는 최단경로문제**, **서울에서 I로 가는 최단경로문제**, **서울에서 J로 가는 최단경로문제**를 풀어야 하는 것. 

  ![5_1](./resources/5_4.png)

  H까지의 최단거리에 +4, I까지의 최단거리 +6, J까지의 최단거리 +8를 비교해보면 서울부터 부산까지의 최단거리를 알 수 있음. *이번에도 부분문제들의 최적의 답을 이용해서 전체문제의 최적의 답을 구한 것.* 

  ![5_1](./resources/5_5.png)

  아까 피보나치 처럼 부분문제의 답을 다 더한 것은 아니여도, 부분문제의 최적의 답을 **이용**해서 전체 문제의 최적의 답을 찾은 것이기 때문에 이 문제도 **최적부분구조**가 있는 것. 



- #### 중복되는 부분 문제(overlapping Subproblems)

  부분문제에서 재귀함수의 개념을 여러번 봤음. 

  ![5_1](./resources/5_6.png)*fib(5)*를 해결하기 위해서는 *fib(4)*와 *fib(3)*을 해결해야 함. 근데 *fib(4)*를 해결하기 위해선 *fib(3)*과 *fib(2)*를 해결해야 함. 

  아래가 해결을 위한 부분문제들 나열한 것인데, 잘 보면 중복되는 부분문제들이 있음. 

  ![5_1](./resources/5_7.png)

  *fib(7)*을 계산하려고 해도 중복으로 엄청 여러번 나옴.![5_1](./resources/5_8.png)

  이런것을 중복되는 부분문제 즉, **Overlapping Subproblem**이라고 부름. 이렇게 중복되는 부분문제를 여러번 계산하는 것은 굉장히 비효율적임. 이걸 해결하는 것이 이번 챕터에서 배울 Dynamic Programming. 

  다만, 문제를 부분문제로 나눈다고 해서 항상 중복되는 부분문제가 있는 것은 아님. 

  예를 들어 합병정렬은 오른쪽 절반과 왼쪽 절반을 해결하는 과정이 완전히 서로 아무 상관도 없음. 서로 겹치는게 없을 가능성이 높음. 즉 이런 경우는 합병되지 않는 부분문제(Non-Overlapping Subproblem)임. 

  ![5_1](./resources/5_9.png)

