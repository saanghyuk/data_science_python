# Data Structure 1 

## 자료 구조란?

- 자료 구조란?

  자료구조란 우리가 데이터를 저장하고 관리하기 위해 사용하는 구조를 의미한다. 

  예를 들어 도서관에서 로미오와 줄리엣 이라는 책을 찾고 싶다면? 카테고리를 찾아가서, 가나다순으로 찾아 가야지. 중요한건 도서관에서 우리가 이렇게 로미오와 줄리엣을 찾을 수 있는 것은 이미 그 책이 일정한 구조 속에 있었기 때문. 

  ![1_1](./resources/1_1.png)

  이러한 구조가 유지되는 이유는 약속을 정하고, 그 약속대로 책을 정리하는 사서들이 있기 때문. 이 약속들 덕분에 누구나 쉽게 찾을 수 있는 것. 

  컴퓨터에 데이터를 정리할 때도, 도서관에 책을 정리하는 것처럼 일정한 구조에 맞게 저장을 함. 컴퓨터 과학에서는 이런 구조를 자료구조 라고 부른다. 

  ![1_1](./resources/1_2.png)

  프로그래밍을 하다 보면, 다양한 데이터를 다루게 됨. 어떤 데이터든 저장하고, 저장한 내용을 가지고 올 수 있어야 함. 데이터를 쉽게 찾기 위해서는 구조가 필요하다. 자료 구조에서는 데이터를 관리하는 다양한 방식을 배우고, 여러 상황에서 가장 적합한 구조를 고르는 방법을 배울 것. 



- #### 상황에 맞는 자료 구조

  본격적으로 자료 구조를 배우기 전에, 적합한 자료 구조를 고르지 못했을때의 비효율에 대해 알아보자. 

  사실 리스트와 세트는 자료 구조 이름은 아니다. 그냥 파이썬 자료형이 이름. 중요한 것은 두 가지가 서로 다른 구조/방식을 이용해서 자료를 저장한다는 것. 

  ![1_1](./resources/1_3.png)

  ![1_1](./resources/1_4.png)

  time을 이용해서, 두가지가 같은 동작을 하는데 시간이 얼마나 차이나는지를 체크해봄. 

  실행해보면, 세트에 포함된 정수를 찾는 것이 리스트에서 찾는 것보다 훨씬 빠름. 3000배 더 걸려. 

  ![1_1](./resources/1_5.png)

  이게 엄청 큰 차이. 

  방금 본 예시에서는 set를 쓰는게 리스트를 쓰는 것보다 더 효율적이였음. 그렇다고 해서 당연히 항상 좋은 것은 아님. 각 자료구조마다 장/단점이 있다. 

  **자료구조를 공부해야 어떤 자료구조들이 존재하고, 어떤 상황에 뭘 써야 하는지를 알 수 있다.**

   

## 컴퓨터가 데이터를 저장하는 법

- #### 스토리지 vs 메모리

  자료구조의 목적은 말그대로 **자료를 구조화 해서 데이터를 효율적으로 사용하는 것.**

  ![1_1](./resources/1_6.png)

  자료 구조를 배우려면, 컴퓨터에 데이터가 어떻게 저장되는지에 대한 최소한의  지식이 필요함. 

  **컴퓨터는 데이터를 크게 두 곳에 저장한다. 스토리지와 메모리.**

  ![1_1](./resources/1_7.png) 

  스토리지는 데이터가 영구적으로 저장되는 곳. 우리가 컴퓨터에 저장하는 음악/사진/영화 등. 스토리지에 있는 데이터는 사용자가 직접 지우거나, 컴퓨터에 심각한 외부 충격이 있지 않은 이상은 영원히 저장됨. 

  ![1_1](./resources/1_8.png)

  ![1_1](./resources/1_9.png)

  스토리지는 영원히/많이 저장할 수 있는 대신, 데이터를 저장하는데도 오래 걸리고, 데이터를 받아오는데도 오래 걸린다. 

  약간 창고 같은 느낌임. 당장 필요한게 아니라, 나중에 두고두고 사용할 것들을 저장함. 

  **정확히 언제 사용할지 모르겠는 파일들을 저장한다.** 

  ![1_1](./resources/1_10.png)

  메모리는? 데이터를 임시로 저장하는 곳. 

  워드로 과제를 하고 있는데, 아직 저장 안눌렀다면? 메모리에 임시적으로 저장된 것. 

  컴퓨터 꺼지면, 작업중이였던 내용 다 날라감. 쓰다가 저장을 눌렀다면, **메모리에서 스토리지로 복사되는 거지.** 

  ![1_1](./resources/1_11.png)

  ![1_1](./resources/1_12.png)

  보통은 컴퓨터의 스토리지 용량이 메모리 용량보다 큼. 작은 대신 메모리는 데이터를 저장하는 것과 가지고 오는 것을 엄청 빠르게 할 수 있음. 메모리는 책상 서랍 정도. 창고에 비해서 크기는 작지만, 물건을 빨리 가져올 수 있도록, 손 닿는 곳에 딱 있는 느낌. 그래서 메모리는 오래 보관하는 데이터가 아닌, 지금 당장 사용해야 하는 데이터를 저장함. 

  ![1_1](./resources/1_13.png)

  근데 뭔지는 알겠는데, 왜 두가지가 다 필요한 걸까?

  *컴퓨터로 영화를 본다고 해보자.*

  영화는 스토리지에 저장되 있겠지. 근데, 영화를 본다는 것은 스토리지에서 한장면 한장면씩 빼오는 것.  이 한 장면 장면을 실시간으로 스토리지에서 뽑아 오면? 스토리지는 데이터를 가지고 오는데 시간이 오래걸림. 그러니깐, 이런식으로 가져오면 영화가 계속 끊길 수 밖에 없음. 스토리지의 이런 단점을 해결해 주는 것이 메모리. 영화를 키면 스토리지에 있던 영화를 메모리로 복사한다. 메모리는 받아오는게 빠르니깐, 쾌적하게 영화를 보게 해줌. 그 대신 영화를 끄면, 메모리에 있던 영화 데이터는 사라지고, 다시 스토리지에만 영화가 있겠지. 

  ![1_1](./resources/1_14.png)

  자료구조에서 하는 얘기는 대부분 메모리 얘기. 자료구조는 메모리에서 잘 사용하게 하는 것이 목적. 

- #### RAM : Random Access Memory

  비유를 하자면, 메모리는 일종의 긴 띠라고 볼 수 있음. 일정한 칸으로 나뉘져 있고, 각 칸에는 데이터를 저장할 수 있다. 그리고, 데이터를 찾을 수 있게끔, 각 칸은 자신만의 주소가 있다. 

  ![1_1](./resources/1_15.png)

  예를 들어 아래와 같은 코드를 썻다면, 메모리 어딘가에 95를 저장하고 어딘가에 True를 저장했겠지. 

  ![1_1](./resources/1_16.png)

  그럼 어딘가 저장되어 있는 곳에서 컴퓨터는 어떻게 이 값들을 받아오게 될까?

  ram은 임의접근메모리라는 뜻. 임의 접근이라는 뜻은 저장 위치를 알면 접근할 때, 항상 일정한 시간이 걸린다는 뜻. 램은 데이터가 95라는 주소에 있던, 193이라는 주소에 있던, 152581이라는 주소에 있던, 다 한번에 찾을 수 있다는 뜻. 

  ![1_1](./resources/1_17.png)

  시간복잡도로 얘기하자면 O(1)인 거지. ![1_1](./resources/1_18.png)

  이게 사실 엄청 대단한거야. 비디오테이프였으면, 1시간 20분을 찾으려면 현재 위치부터 1시간 20분까지 테이프를 돌려야 되잖아. 이런 비디오테이프 같은 것을 순차접근이라고 하는데, 순차접근이면 저장된 위치까지 가는데 한 단계씩 거쳐야 하기 때문에 멀리까지 가려면 더 많은 시간을 써야 함. 

  ![1_1](./resources/1_19.png)

  근데 임의접근을 하면 주소와 상관없이 항상 일정하게 갈 수 있음. 

  **자료구조를 공부하면, 메모리에 데이터를 저장하고 찾고 이런 얘기를 계속 하게 되는데, 메모리는 임의접근으로 동작한다는것을 항상 기억하고 있어야 한다.** 

- #### 메모리의 기본 단위 : 바이트

  ![1_1](./resources/1_20.png)

  메모리는 하나의 긴 띠라고도 표현했는데요. 이 띠는

  1. 일정한 칸으로 나눠져 있고
  2. 각 칸에 데이터를 저장할 수 있고
  3. 각 칸은 자신만의 주소가 있습니다

  이 메모리 한 칸이 저장할 수 있는 가장 기본적인 용량의 단위는 **바이트**, 영어로는 **byte**입니다. 자료 구조를 공부하면서 바이트라는 단위가 정확히 얼만큼의 정보를 저장하는 단위인지는 모르셔도 됩니다. 그냥 엄청 작은 단위라고만 알고 계시면 됩니다.

  바이트가 아닌 다른 크기의 용량을 담는 저장 장치들도 있긴 한데요. 대부분의 현대 컴퓨터 시스템들은 메모리 한 칸에 바이트만큼의 데이터를 저장합니다.

  일상 생활 속에서도 많은 분들께서 이미 바이트라는 용어를 들어보셨을 텐데요. 흔히 영상, 문서, 음성 파일이나, RAM 또는 컴퓨터의 스토리지의 크기를 표현할 때,

  - 160 킬로 바이트(kB)
  - 10 메가 바이트(MB)
  - 32 기가 바이트(GB)

  이런 식으로 많이 표현하는데요. 킬로 바이트, 메가 바이트, 기가 바이트는 그냥 데이터의 용량이 몇 바이트인지 표현한 겁니다. 정확히 얘기하자면,

  - 킬로 바이트 = 1,000 바이트
  - 메가 바이트 = 1,000,000 바이트
  - 기가 바이트 = 1,000,000,000 바이트

  이만큼의 저장 공간 용량들이죠.

  자료 구조를 배우면서 바이트나 다른 저장 공간 단위들을 심도 있게 다루지는 않을 건데요. 그래도 자료 구조에서는 이해하면 도움이 되는 개념/용어이니까,

  1. 바이트는 컴퓨터 저장 공간 용량을 나태내는 단위다.
  2. 메모리 한 칸에 담기는 데이터 용량은 1 바이트다.

  이 정도는 이해하고 넘어가시면 나중에 나오는 내용을 이해하는 데 조금 더 수월할 거예요!



- #### 레퍼런스

  사실 x=95를 저장했다고, **x는 95다** 라고 말하면 틀린 표현에 가까움. 왜냐면, x는 95라는 값 자체를 들고 있는 것이 아니라, 95라는 값이 저장된 주소를 가지고 있을 뿐이기 때문. 이 주소값을 이용해서 정수값 95라는 값을 찾아오는 것일 뿐임. 

  ![1_1](./resources/1_21.png)

  이렇게 데이터에 접근하게 해주는 값을 레퍼런스 라고 함. 레퍼런스랑 주소는 또 살짝 다름. 주소는 메모리의 진짜 그 실질적인 주소를 나타내고, 레퍼런스는 살짝 추상적인 개념인데, **데이터에 접근할 수 있게 해주는 값을 포괄적으로 나타냄.** x =95같은거는 주소 자체가 레퍼런스 이기도 함. 근데 항상 그런 것은 아님. 

  그런데 사실 자료구조를 공부할때는 두 가지를 그냥 동일하다고 생각해도 아무 문제가 없음.  

  ![1_1](./resources/1_22.png)

  근데 변수에 레퍼런스가 들어 있으면, x+5하면, 주소값이랑 5를 더하는 거냐?

  당연히 아니지. 실제로 값을 사용할때는 파이썬이 저장된 값을 알아서 받아오는 것. 파이썬이 이런 과정을 다 추상화해놓고 해주기 때문에, 우리가 x가 95라고 착각하는 거야. 

  ![1_1](./resources/1_23.png)



- #### 데이터의 주소

  **파이썬 id 함수**

  데이터가 저장되어 있는 주소를 알아내는 방법을 볼게요.

  `id` 함수를 이용하면 저장한 데이터의 메모리 주소를 정수로 표현한 값을 알아낼 수 있습니다. 여러 타입의 데이터를 저장하고 `id` 함수를 써서 메모리 주소를 출력시켜보겠습니다.

  ```python
  # 여러 데이터를 저장한다
  list1 = [1, 2]
  int1 = 0
  float1 = 3.14
  set1 = set()
  tuple1 = (2, 3)
      
  # 저장한 데이터의 메모리 저장 위치를 받아온다
  print(id(list1))
  print(id(int1))
  print(id(float1))
  print(id(set1))
  print(id(tuple1))
  
  
  140237662138184
  4450309504
  140237661913472
  140237664406888
  140237662993992
  ```

  데이터가 각각 다른 메모리 주소에 저장돼 있군요.

  주소는 코드를 돌릴 때마다 다르게 나오니까 여러분 컴퓨터에 다르게 출력되어도 놀라지 마세요!

  **같은 주소에 저장돼 있는 데이터**

  좀 당연한 말같이 들리실 수도 있는데요. 똑같은 주소에 저장돼 있는 데이터는 똑같은 데이터입니다.

  ```python
  # 리스트를 정의한다
  list1 = [1, 2]
  list3 = [1, 2, 3]
      
  # Aliasing을 통해 list1과 list2를 같게 한다
  list2 = list1
      
  # 두 데이터의 메모리를 출력한다
  print(id(list1))  # 140657629409160
  print(id(list2))  # 140657629409160
  print(id(list3))  # 140657629409096
  ```

  위 코드를 살펴봅시다. 세 변수 `list1`, `list2`, `list3`를 만들었습니다.

  `list1`은 정수 `1`, `2`를, 그리고 `list3`은 `1`, `2`, `3`을 담고 있는 리스트입니다.

  그리고 `list2`에  `list1`를 지정했습니다. 메모리에서 만든 하나의 같은 리스트를 `list1`, `list2`라는 두 개의 다른 변수가 가리키고 있는 거죠. 이렇게 여러 변수가 같은 메모리를 가리키는 것을 **Aliasing**이라고 합니다.

  `id` 함수를 써서 `list1`과 `list2`의 메모리 주소를 출력해 보면 같다고 나오죠? `list3`는 다른 주소에 저장되어 있습니다. `list1`과 `list2`는 서로 같은 리스트를 가리키고 있기 때문에 똑같은 메모리가 출력되고, `list3`는 전혀 다른 리스트를 가리키고 있기 때문에 다른 메모리가 출력되는 거죠.