# NUMPY

- numpy array 

| method                               | Role/result                                                  |
| ------------------------------------ | ------------------------------------------------------------ |
| `numpy.array([*<python.array>*])`    | make ndarray                                                 |
| `array1.shape`                       | `(3, 4)`                                                     |
| `array1.size`                        | `12` # 총 갯수                                               |
| `numpy.ful(6, 7)`                    | `[7 7 7 7 7 7]`<br>6개의 동일한 7이 ndarray로 만들어짐. <br>모든 값이 같은 numpy array를 생성할 수 있습니다. |
| `array2 = numpy.zeros(6, dtype=int)` | `[0 0 0 0 0 0]`<br>모든 값이 0인 numpy array 생성            |
| `array1 = numpy.random.random(6)`    | `[0.42214929 0.45275673 0.57978413 0.61417065 0.39448558 0.03347601]`<br />랜덤한 값들로 생성해줌. |
| `array1 = numpy.arange(6)`           | `[0, 1, 2, 3, 4, 5 ]`<br />연속된 값들이 담긴 numpy array 생성 |
| `array1 = numpy.arange(2, 7)`        | `[2 3 4 5 6]`<br />`arange(n, m)`을 하면 `n`부터 `m-1`까지의 값들이 담긴 numpy array가 리턴됩니다. |
| `array1 = numpy.arange(3, 17, 3)`    | `[ 3  6  9 12 15]`<br />`arange(n, m, s)`를 하면 `n`부터 `m-1`까지의 값들 중 간격이 `s`인 값들이 담긴 numpy array가 리턴됩니다. |




### Indexing & Slicing

| array1 = np.array([2, 3, 5, 7, 11, 13,<br /> 17, 19, 23, 29, 31, 33]) | roles                                                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `array1[0]`                                                  | `2`                                                          |
| `array1[-1]`                                                 | `33`                                                         |
| `array1[-2]`                                                 | `31`                                                         |
| `array1[[1, 3, 4]]`                                          | `3, 7, 11` <br />1, 3, 4번 인덱스 숫자들을 가져옴            |
| `array2 = np.array([2, 1, 3])`<br/>`array1[array2]`          | `array([5, 3, 7])`<br />array2 안에 들어 있는 2번 1번 3번의 숫자를 끌어와서 새로운 array를 리턴함 |
| `array1[2:7]`                                                | array([ 5,  7, 11, 13, 17])                                  |
| `array1[0:7]` or `array1[:7]`                                | `array([ 2,  3,  5,  7, 11, 13, 17])`                        |
| `array1[2:]`                                                 | `array([ 5,  7, 11, 13, 17, 19, 23, 29, 31, 33])`            |
| `array1[2:11:2]`                                             | `array([ 5, 11, 17, 23, 31])` <br />2번부터 10번까지의 인덱스를 2칸 단위로 건너 뛰면서 가지고 옴. |



### Basic Calculation

```
array1 = array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
array2 = array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])
```

| methods                                           | results & roles                                              |
| ------------------------------------------------- | ------------------------------------------------------------ |
| `array1*2`                                        | `array([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18])`<br />모든 값에 곱하기 2 |
| `array1/2`                                        | `array([0. , 0.5, 1. , 1.5, 2. , 2.5, 3. , 3.5, 4. , 4.5])`  |
| `array1**2`                                       | `array([ 0,  1,  4,  9, 16, 25, 36, 49, 64, 81])`            |
| `array1+1`                                        | `array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])`            |
| `print(id(array1))`<br/>`print(id(array1*2))`     | `140636996531584`<br />`140636992284112`<br />여기가 가장 중요한 부분! array는 연산을 한 순간 다른 객체가 됨. 기존 array1은 똑같은 상태로 보존됨 |
| `array1+array2`                                   | `array([10, 12, 14, 16, 18, 20, 22, 24, 26, 28])`<br />같은 차원에서 서로 같은 자리끼리 더함. 물론 그 외에도 **사칙연산(+-*/)이 모두 가능함**. |
| `print(array1.max()) `<br />`print(array1.min())` | `max` 메소드와 `min` 메소드를 사용하면 numpy array의 최댓값과 최솟값을 구할 수 있습니다. |
| `print(array1.mean())`                            | `mean` 메소드를 사용하면 numpy array의 평균값을 구할 수 있습니다. |
| `np.median(array1)`                               | `median` 메소드를 사용하면 중간값을 구할 수 있는데요. 특이하게 `median`은 numpy array의 메소드가 아니라 numpy의 메소드입니다. |
| `print(array1.std())` `print(array1.var())`       | 표준편차<br />분산                                           |
|                                                   |                                                              |



##### Boolean Calculation

| methods                                               | results & roles                                              |
| ----------------------------------------------------- | ------------------------------------------------------------ |
| `array1 >4`                                           | `array([False, False, False, False, False,  True,  True,  True,  True,  True])` |
| `array1 %2 == 0`                                      | `array([ True, False,  True, False,  True, False,  True, False,  True, False])` |
|                                                       |                                                              |
| *boolean array setting*                               | `booleans = np.array([True, True, False, True, True, True, False, True, True, False])` |
| `np.where(booleans)`                                  | `(array([0, 1, 3, 4, 5, 7, 8]),)`<br />*True가 담겨있는 인덱스를 리턴* |
| `filter = np.where(array1 > 4)`<br />`array1[filter]` | Filter ->  `(array([5, 6, 7, 8, 9]),)`<br />`array([5, 6, 7, 8, 9])`<br />지금 array1이 0~8로 구성되어 있어서 티가 안나지만, np.where로 **True인 값들의 인덱스**를 가져온 다음에, 그 인덱스를 array1에 넣어서 **인덱싱** 한 것. |
|                                                       |                                                              |
|                                                       |                                                              |



### Reference

- 파이썬 리스트와 넘파이 어레이의 차이

| 함수                    | numpy array                              | python list                                                  |
| ----------------------- | ---------------------------------------- | ------------------------------------------------------------ |
| list 덧셈               | 각 인덱스의 값들끼리 더해짐              | 뒤로 쭉 길게 이어져서 새로운 리스트가 됨.                    |
| list 뺄셈, 곱셈, 나눗셈 | 각 인덱스 값들끼리 연산                  | error                                                        |
| list + 5, -5, /5        | 내부 모든 값들에 5가 더해짐/빼짐/나눠짐. | error                                                        |
| list*3                  | 내부 모든 값들에 3씩 곱해짐              | 해당 리스트가 뒤로 3번 이어짐. 예를 들어 <br />`[1, 2] *3` => `[1, 2, 1, 2, 1, 2]` |
|                         |                                          |                                                              |

- 성능차이가 실제로 엄청나게 남. 말도 안되는 정도로 격차가 나기도 함. 왜냐면 값들이 저장되는 방식의 차이 때문. 파이썬 리스트에서는 다양한 값들을 한꺼번에 넣을 수 있음. 예를 들어, `[1, 'hi', True, 3.0, 5]`. 하지만, 넘파이 어레이는 한 자료형만 넣을 수 있는 대신 속도를 엄청나게 개선 시킨 것. 
- 수치 계산보다는 값을 추가하고 제거하는 일만 하면 파이썬 리스트가 효율적이지만, 수치 계산/행렬같은 다차원 배열이 필요한 경우는 넘파이를 쓰는게 훨씬 효율적. 