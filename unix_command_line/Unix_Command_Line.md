# Unix Command Line

![1_1](./resources/1_23.png)

| command | 기능             | 비고                                                         |
| ------- | ---------------- | ------------------------------------------------------------ |
| clear   | 화면 깨끗하게    |                                                              |
| date    | 시간 보여준다.   |                                                              |
| cal     | 달력을 보여준다. | `cal 2030` 2030년 달력 출력<br>`cal 3 2030` 2030년 3월 <br>` cal - y`  - 올해 달력 출력 |
|         |                  |                                                              |
|         |                  |                                                              |
|         |                  |                                                              |
|         |                  |                                                              |
|         |                  |                                                              |
|         |                  |                                                              |
|         |                  |                                                              |
|         |                  |                                                              |
|         |                  |                                                              |



- #### CLI환경이란?

  세상에는 수 많은 운영체제들이 있다. 

  ![1_1](./resources/1_1.png)

  운영체제들의 내부까지 다 알필요는 없지만, 적어도 command를 알아야 운영체제들을 동작시킬 수 있다. 

  아래 운영체제들은 모두 단 하나의 운영체제로부터 발전됬다. 때문에 기본 커맨드가 거의 동일하다. 유닉스 커맨드만 배우면 된다. 

  ![1_1](./resources/1_2.png)

  보통 운영체제에는 대략 1000개의 명령어가 있지만, 여기서 대충 2~30개만 알아도 업무에 전혀 지장이 없다. 



- #### Unix(Unix-Certified)와 유사Unix(Unix-Like)

  수 많은 운영체제들이 Unix라는 동일한 뿌리를 가지고 있음. 유닉스의 인기 덕분에, C언어까지 덩달아 인기를 얻음. 

  ![1_1](./resources/1_3.png)

  Unix가 하도 많이 변형되어 사용되니깐, 어느정도 제한을 두기 위해, Posix라는 규격을 만들기도 하였다. 

  ![1_1](./resources/1_4.png)

  그런데 당시 유닉스라는것이 벨 연구소꺼였는데 벨 연구소가 AT&T소속이다 보니, 유닉스를 사용하거나 변형할때 AT&T에 라이센스비를 내야 했음. 

  이걸 반대하는 사람들이 있었음. 공유의 문화를 옹호하던 사람들이 유닉스 코드를 하나도 사용 안하고, 유닉스와 유사한 운영체제를 만들었다. 

  ![1_1](./resources/1_5.png)

  이렇게 만들어지기 시작한 운영체제가 GNU. 

  ![1_1](./resources/1_6.png)

  그런데 그 중에 커널이라고 하는 운영체제의 핵심부분이 잘 완성되지 않고 있었음. 그때 핀란드에 있던 리누스 토발즈라는 사람이 새로운 커널 하나를 만들었고 그것을 Linux라는 이름으로 공개했음. 

  ![1_1](./resources/1_7.png)

  GNU프로젝트에서는 이것을 쓰기로 했고, 그 결과 드디어 GNU운영체제가 완성되었다. GNU운영체제에 Linux커널을 더해서 만들었기 때문에, 이 운영체제를 GNU/Linux라고 부른다. **우리가 흔히 말하는 리눅스는 이처럼 커널에 해당한다. 운영체제를 말할때는, GNU/Linux라고 말하는게 맞긴 한데 그냥 리눅스라고 부름. **

  ![1_1](./resources/1_8.png)

  Unix도 인기가 많았는데, 그것을 자유롭게 만들어서 배포해버리니 파급효과가 엄청 컸지. 

  ![1_1](./resources/1_9.png)

  이 수 많은 배포판 들 중에서도, POSIX인증을 받으면 Unix-Certified가 되고, 인증받지 못했지만 사용하기에 기능적으로 차이가 없는 정도랴면, Unix-Like라고 부른다. 근데 사실 Unix-Like에는 그냥 비용이 부담되서 인증 안받는 애들이 많음. 

  ![1_1](./resources/1_10.png)

  이 모든 애들이 사실 Command는 싹다 똑같아. 그래서 배우면 엄청 효율적인 것. 

  ![1_1](./resources/1_11.png)

  

- #### GUI와 CLI

  컴퓨터를 사용하는 환경은 크게 두가지. 그래픽화면에서 마우스 사용하는 것. GUI. 

  ![1_1](./resources/1_12.png)

  키보드로 커맨드 입력

  ![1_1](./resources/1_13.png)

  ![1_1](./resources/1_14.png)

  왜 CLI를 사용하는 걸까? 원래 CLI밖에 없긴 했는데, 지금은 사실 컴퓨터의 대중화와 함께 GUI가 대부분. 이런데도 CLI를 쓰는 거는 특히 CLI의 장점을 부각시키고 싶은 상황. 

  1. **성능**: GUI에서 예쁜거 보여준다는 거는, 그만큼 뭐가 많다는 거야. 그런거 다 빠지고 글자만 보여주는게 성능이 당연히 훨씬 빠르겠지. 
  2.  **명확성**: 실행 자체가 더 명확해. GUI는 실수로 뭐 잘못하고 복잡할 확률이 높아. CLI 에서는 여러 단계에 걸친 실행도  한줄로 가능함. 



- #### MAC OS의 역사 

  이전 영상에서 macOS는 유닉스 계열에 속하고, 유닉스 관련 표준을 준수하는 Unix-certified 운영 체제라고 했는데요. 그래서 유닉스 커맨드를 macOS에서도 사용할 수 있다고 했구요. macOS와 유닉스가 역사적으로 어떤 관계가 있는지 좀더 자세히 설명해드릴게요. 리눅스가 유닉스를 기반으로 만들어진 운영 체제라고 했었죠? 그런데 사실 유닉스를 기반으로 만들어졌던 운영 체제에는 리눅스뿐만 아니라 다른 것도 있었습니다. 바로 **BSD(Berkerly Software Distribution)**라고 하는 운영 체제입니다. BSD는 리눅스보다도 더 이전에 탄생한 운영 체제인데요. 유닉스가 여러 곳에서 사용되고 있던 1978년, 미국 UC 버클리(Berkerly, BSD의 첫 글자) 대학의 대학원생이었던 빌 조이(Bill joy)와 척 핼리(Chuck Haley)는 기존의 유닉스를 개량하여 BSD라는 운영체제를 개발했습니다. 이 BSD는 계속 버전이 올라가면서 널리 쓰이기 시작했고 버전이 올라가서 4.3BSD까지도 개발이 되었습니다.

  그리고 NeXT라는 컴퓨터 회사에서 이 4

  .3BSD를 기반으로 NeXTStep이라는 운영 체제를 개발했는데요. NeXT는 사실 스티브 잡스가 그 당시 Apple 내에서 여러 갈등을 겪고 쫓겨난 후에 세운 회사입니다. Apple에서 쫓겨난 잡스가 자신만의 통찰력을 가지고 새로운 시도 혹은 재기를 하기 위해 만든 회사였죠. NeXT에서 만든 운영 체제, NeXTStep은 그 안에 구현된 진보적인 기술들로 인해 많은 주목을 받았는데요. 이 즈음에 잡스가 빠진 Apple은 기존에 가지고 있던 운영 체제의 한계를 극복할 차세대 운영 체제를 만들기 위해 노력하던 중이었습니다. 이를 위해 여러 내부 프로젝트를 시작했지만 매번 실패했고, 결국 외부에서 개발된 좋은 운영 체제를 가져와야겠다는 결심을 하게 됩니다. 이때 NeXTStep이 그 후보 중 하나였는데요. Apple은 결국 당시 존재하던 운영 체제 중에서 NeXTStep을 가져오자는 결정을 내립니다. 그리고 이를 위해 NeXT를 인수하였고 동시에 스티브 잡스는 다시 Apple로 돌아오게 되었습니다.

  그 뒤로 Apple에서는 이 NeXTStep을 Apple의 기기에 이식하기 위한 프로젝트를 시작했고, NeXTStep은 오늘날 Apple에 존재하는 다양한 운영 체제인 iOS, macOS, watchOS 등의 기초가 되었습니다. 뭔가 이야기가 길어졌죠? 결국 정리하자면 오늘날의 macOS는 `Unix - BSD - NeXTStep - macOS` 순의 역사를 거쳐 탄생한 것입니다. 물론, 그 사이에 기술적으로 더 설명해야할 부분도 있고 다른 운영 체제 이름들도 들어가야 하지만 큰 흐름은 이렇습니다. 왜 macOS도 역사적으로 그 뿌리가 결국 Unix인지 이제 알겠죠?



- #### CLI 첫걸음 - 터미널 켜보기

  ```
  clear
  ```

- #### 커맨드를 내 입맛에 맞게 사용해보기

  1. **인자 사용**

     `cal 2030` - 2030년 전체 달력이 출력된다. 

     `cal 3 2030` - 2030년 3월

  2. **옵션 사용**

     `cal - y` 올해의 전체 달력

     

     

  인자와 옵션은 정해진 방식대로 사용해야 한다. 

  `cal 2030` `cal 3 2030` ` cal - y` 



- #### 인자와 옵션의 차이점

  이전 영상에서는 인자와 옵션을 사용해봤는데요. 

  그런데 인자와 옵션은 정확히 어떤 차이가 있는 걸까요?

  1. 인자는 커맨드가 작동할 대상을 지정하기 위해 사용되고, 
  2. 옵션은 커맨드가 구체적으로 어떤 방식으로 동작할지를 지시하기 위해 

  사용된다고 했는데요. 아래 커맨드를 볼까요? 

  ```
  cal -y 
  ```

  여기서 `-y`는 옵션이라고 배웠죠?

  이렇게 하이픈이 붙은 게 옵션입니다. 

  그리고 

  ```
  cal 2020
  ```

  여기서 2020은 인자입니다. 인자의 경우에는 하이픈이 없습니다. 이렇게 옵션과 인자는 

  1. 형식적인 측면과(하이픈이 있는지, 없는지) 
  2. 의미적인 측면(커맨드에서 보통 어떤 성격의 지시를 나타내는지)

  둘 다에서 차이가 납니다. 사실 옵션도 넓은 의미에서 인자라고 하는 경우도 있지만 구별해서 말하는 경우가 보통 더 많습니다.

  앞으로 누군가가 써놓은 커맨드를 볼 때 커맨드 이름 뒤에 옵션과 인자가 섞여 있다면 하이픈을 기준으로 뭐가 옵션이고, 뭐가 인자인지 구분할 수 있겠죠?



- #### 옵션에 관해 알아야 할 내용

  이전 영상에서는 커맨드에 인자와 옵션을 줄 수 있다는 것을 배웠습니다. 이번 노트에서는 옵션에 대해서 좀 더 자세히 알아볼게요. 옵션 중에는 그 뒤에 어떤 값을 한 칸 띄우고 이어서 적어야 하는 것들이 있습니다. 예를 들어 `cal` 커맨드의 옵션 중에는 현재 날짜가 있는 달로부터 그 이전 달들의 달력도 함께 출력해주는 `-B` 옵션이 있는데요. `-B` 옵션은 before의 줄임말입니다. 아래 그림과 같이 `-B` 옵션에 값으로 2를 주면, 현재 달로부터 그 이전의 2개 달의 달력도 함께 출력합니다.

  ![1_1](./resources/1_15.png)

  신기하죠? 이렇게 옵션에 주는 값을 옵션의 값(value)이라고 하거나 옵션의 인자(argument)라고 합니다. `cal` 커맨드의 옵션 중 이렇게 값을 줘야 하는 옵션에는 `-A` 옵션도 있는데요. `-A` 옵션은 after의 줄임말입니다. `-A` 옵션을 주면 현재 달로부터 그 이후에 있는 달들의 달력도 출력할 수 있습니다. 아래 그림과 같이 `-A` 옵션에 값으로 3을 주면 현재 달부터 그 뒤의 3개 달의 달력까지 함께 출력할 수 있습니다. 

  ![1_1](./resources/1_16.png)

  만약 값을 줘야 하는 옵션에 값을 주지 않는다면 어떻게 될까요? `-A` 옵션에 값을 주지 않고 실행했더니 아래 그림처럼 커맨드가 실행되지 않네요. 

  ![1_1](./resources/1_17.png)

  지금 위 그림에서 `option requires an argument -- 'A'` 라고 쓰여진 부분 보이시나요? `-A` 옵션에 값(여기서는 옵션의 인자를 나타내기 위해 value 대신 argument라는 단어가 쓰였습니다)이 없다는 뜻입니다. 그리고 그 밑에는 `cal` 커맨드의 일반적인 사용법들이 출력되어 있습니다. 이런 사용법 중에 하나로 써야 한다는 뜻인데요. 값을 줘야 하는 옵션은 꼭 값을 주고 써야 한다는 사실을 기억하세요.

  그리고 옵션은 여러 개를 쓰는 것도 가능합니다. 아래 그림처럼 `-B` 옵션과 `-A` 옵션을 함께 쓸 수도 있습니다. 

  ![1_1](./resources/1_18.png)

  위 그림의 결과를 보면 지금 현재 달로부터 2달 전까지의 달들, 현재 달로부터 3달 후까지의 달들의 달력이 모두 출력됩니다. 이렇게 옵션은 여러 개를 동시에 쓸 수도 있습니다. 

  그리고 값을 줘야 하는 옵션이든 값을 주지 않는 옵션이든 자유롭게 섞어 쓸 수 있는데요. `cal` 커맨드의 옵션 중에서 값을 주지 않는 옵션으로는 `-j` 옵션이 있습니다. `-j` 옵션을 쓰면 모든 날짜를 1월 1일을 기준으로 몇 번째 날짜인지 표시하는 방식으로 달력을 출력하는데요. 방금 전 썼던 옵션들과 함께 써보면 

  ![1_1](./resources/1_19.png)

  아까와 같이 6개 달의 달력이 출력되지만 각 날짜를 자세히 보면 차이가 있습니다. 지금 12월의 마지막 날짜를 보면 365라고 적혀있죠? 1월 1일을 기준으로 365번째 날이라는 뜻입니다. `-j` 옵션이 적용되었기 때문에 그런 겁니다. 

  이렇게 값을 줘야 하는 옵션이든, 값을 주지 않는 옵션이든 섞어 쓸 수 있습니다.

  마지막으로 한 가지 더 알려드릴게요. 여러 옵션을 동시에 쓸 때는 하이픈(`-`) 하나 뒤에 여러 옵션의 이름을 써도 됩니다. 예를 들어 바로 위에 입력한 내용은 아래와 같이 입력해도 같은 결과가 나옵니다. 

  ![1_1](./resources/1_20.png)

  지금 옵션 `-j`와 옵션 `-A`를 `-jA`로 함께 쓴 거 보이시나요? 이렇게 써도 같은 결과가 나옵니다.

  아래 그림처럼 옵션 `-B`에 붙여서 `-jB`라고 써도 잘 나옵니다.

  ![1_1](./resources/1_21.png)

  그런데 이렇게 여러 옵션을 함께 쓸 때는 주의할 점이 있습니다. 예를 들어 위 그림의 커맨드에서 `-B` 옵션과 `-j` 옵션의 순서를 바꿔서 `cal -Bj 2 -A 3` 로 적었다고 해봅시다. 

  ![1_1](./resources/1_22.png)

  그럼 에러가 출력됩니다. `-Bj 2`, 이 부분에 문제가 있기 때문에 그런 겁니다. 이렇게 쓰면 `-B` 옵션에는 아무런 값을 안 주고 `-j` 옵션에 2라는 값을 준다는 뜻이 되어버립니다. 하지만 정작 값을 줘야 하는 건 `-B` 옵션이고, `-j` 옵션은 값을 주면 안 되는 옵션입니다. 지금 거꾸로 된 겁니다. 그래서 `cal -Bj 2 -A 3` 가 이상하게 해석되어서 에러가 출력된 것입니다. 값을 줘야 하는 옵션과 값을 주지않는 옵션을 하이픈 하나에 합쳐서 나타내려면 **값을 줘야 하는 옵션을 더 뒤에 써야 합니다.** 그래야 그 다음에 쓰는, 지금 `2`와 같은 값이, 값을 줘야 하는 옵션의 값으로 인식될 수 있습니다. 

  정리하면

  1. 옵션에는 값을 줘야 하는 옵션과, 값을 주지 않아야 하는 옵션이 있고,

  2. 옵션 여러 개를 동시에 쓸 때는 하이픈(`-`) 하나 뒤에 옵션들의 이름을 이어서 쓰는 방식이 있는데

  3. 이때 값을 줘야 하는 옵션이 있다면 값을 줘야 하는 옵션을 가장 뒤에 써야 커맨드가 정상적으로 동작합니다.



- #### 커맨드의 사용법을 알고 싶다면?

  커맨드를 사용하다가 알고 싶다면?

  해당 커맨드에 관한 공식 메뉴얼을 보자. 

  ![1_1](./resources/1_23.png)

  

- #### 공식 메뉴얼 설명을 읽는 방법

  모르는 커맨드가 있을 때는 

  ```
  man [모르는 커맨드]
  ```

  를 실행하면 된다고 했죠? 

  `date`이라는 커맨드에 대해 더 자세히 알고 싶어서 `man date`라고 실행했을 때의 결과를 한번 볼까요?

  ![1_1](./resources/1_24.png)

  색깔별로 구분한 영역들은 순서대로 다음과 같습니다.

  > 1. 섹션, 매뉴얼 이름 : DATE(1)에서 1은 공식 매뉴얼의 전체 내용 중 몇 번째 섹션에 해당하는 곳인지를 말합니다. 대부분의 유닉스 계열의 운영체제는 아래와 같은 여러 섹션으로 구성된 공식 메뉴얼을 갖고 있습니다. 

  | Section |                Description                 |
  | :-----: | :----------------------------------------: |
  |    1    |              General commands              |
  |    2    |                System calls                |
  |    3    |             Library functions              |
  |    4    |         Special files and drivers          |
  |    5    |        File formats and conventions        |
  |    6    |           Games and screensavers           |
  |    7    |                Miscellanea                 |
  |    8    | System administration commands and daemons |

  지금 당장 이 표의 단어들의 의미를 다 알 필요는 없습니다. 다만, 우리가 사용하는 대부분의 커맨드들이 섹션 `1. General commands`에 속한다는 사실만 알고 있으면 됩니다. 

  > 2. NAME : 커맨드의 이름과 커맨드에 대한 간단한 설명입니다. 

  > 3. SYNOPSIS : 어떻게 커맨드를 실행할 수 있는지, 사용 가능한 형식(인자, 옵션들의 조합)을 보여줍니다. 지금 보면 대괄호 안에 있는 것들(`-jRu`)이 사용 가능한 옵션을 나타냅니다. 그리고 대괄호 없는 `new_date` 같은 것이 인자입니다. 

  > 4. DESCRIPTION : 커맨드에 대한 좀더 자세한 설명과 각 옵션에 대한 설명입니다.

  여러 항목들이 있는데 따로 설명이 필요하지 않을 정도로 이해하기에 직관적입니다. 사실 공식 메뉴얼에서 커맨드 하나의 설명을 다 보는 것은 쉬운 일이 아닙니다. 커맨드 하나에 대한 설명도 그 양이 많기 때문인데요. 커맨드에 대한 전반적인 설명 부분이나 특정 옵션에 대해서 정확하게 알고 싶을 때 이 `man` 커맨드를 사용하면 좋습니다. 